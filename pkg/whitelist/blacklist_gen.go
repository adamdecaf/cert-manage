// Copyright 2018 Adam Shannon
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build ignore
// +build ignore

// Generates blacklist.go.
//
// In the history of x509 Certificates and CA's in the wild various accidnets
// and intentional misgivings have occurred.
//
// This blacklist is a collection of known CA's which are commonly removed in
// user applications (e.g. Chrome) and are never allowed in a store generated by
// cert-manage.
package main

import (
	"archive/tar"
	"bytes"
	"compress/gzip"
	"crypto/sha256"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os/user"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/adamdecaf/cert-manage/pkg/certutil"
	"github.com/adamdecaf/cert-manage/pkg/httputil"
)

var (
	// Chrome maintains a .tar.gz file we can download of their blacklisted certificates and keys.
	chromeBlacklistTarball = "https://chromium.googlesource.com/chromium/src/+archive/master/net/data/ssl/blacklist.tar.gz"

	outputFilename = "pkg/whitelist/blacklist.go"
)

func main() {
	when := time.Now().Format("2006-01-02T03:04:05Z")
	who, err := user.Current()
	if err != nil {
		log.Fatalf("Unable to get user on %s", runtime.GOOS)
	}

	var buf bytes.Buffer

	fmt.Fprintf(&buf, `// Copyright 2018 Adam Shannon
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated on %s by %s, any modifications will be overwritten
package whitelist
`, when, who.Username)

	// get certs from tarball
	chromeCerts, err := getChromeCerts(chromeBlacklistTarball)
	if err != nil {
		log.Fatalf("error getting chrome certs, err=%v", err)
	}

	crtshCerts, err := getCrtshCerts([]string{
		"630835231", "631048444", // https://bugzilla.mozilla.org/show_bug.cgi?id=1480853
	})

	certs := append(chromeCerts, crtshCerts...)

	// write certs to file
	fmt.Fprintf(&buf, "var blacklistedFingerprints = []string{\n")
	for i := range certs {
		fmt.Fprintf(&buf, "// %s\n", certs[i].desc)
		fmt.Fprintf(&buf, "`%s`,\n", certs[i].fingerprint)
	}
	fmt.Fprintf(&buf, "}\n")

	// format source code and write to blacklist.gen
	out, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("error formatting output code, err=%v", err)
	}

	err = ioutil.WriteFile(outputFilename, out, 0644)
	if err != nil {
		log.Fatalf("error writing file, err=%v", err)
	}
}

type cert struct {
	// SHA256 fingerprint
	fingerprint string
	// optional, some human level description
	desc string
}

func getChromeCerts(u string) ([]*cert, error) {
	req, err := http.NewRequest("GET", u, nil)
	if err != nil {
		return nil, fmt.Errorf("getChromeCerts: can't build request for %s: %v", u, err)
	}
	req.Close = true

	resp, err := httputil.New().Do(req)
	defer func() {
		if resp != nil && resp.Body != nil {
			err := resp.Body.Close()
			if err != nil {
				log.Println(err)
			}
		}
	}()
	if err != nil {
		return nil, err
	}

	var r io.Reader = resp.Body
	// Decompress gzipped tarball and then read files
	if resp.Header.Get("Content-Type") == "application/x-gzip" {
		r, err = gzip.NewReader(r) // wrap gzip around tar reader
		if err != nil {
			log.Fatalf("error reading gzip'd content, err=%v", err)
		}
	}

	// read files and accumulate certificates (as PEM blobs)
	var certs []*cert
	tfile := tar.NewReader(r)
	for {
		header, err := tfile.Next()
		if err != nil {
			if err == io.EOF {
				break // done with archive
			}
			log.Fatalf("error reading tar header, err=%v", err)
		}

		if header.Size > 0 && header.Typeflag == tar.TypeReg { // regular file
			// collect certificates from files
			if strings.HasSuffix(header.Name, ".pem") {
				bs, _ := ioutil.ReadAll(tfile)
				cs, err := certutil.ParsePEM(bs)
				for i := range cs {
					certs = append(certs, &cert{
						fingerprint: certutil.GetHexSHA256Fingerprint(*cs[i]),
						desc:        cs[i].Subject.String(),
					})
				}

				if len(cs) == 0 { // append whatever we can
					certs = append(certs, &cert{
						fingerprint: header.Name[:sha256.BlockSize],
						desc:        err.Error(), // add whatever error we can, at least it's something
					})
				}
			}
		}
	}

	return certs, nil
}

// Download certificates by their crt.sh id
func getCrtshCerts(ids []string) ([]*cert, error) {
	client := httputil.New()

	wg := sync.WaitGroup{}
	wg.Add(len(ids))

	mu := sync.Mutex{}
	var certs []*cert

	for i := range ids {
		id := ids[i]
		go func(wg *sync.WaitGroup, id string) {
			defer wg.Done()

			address := fmt.Sprintf("https://crt.sh/?d=%s", id)
			resp, err := client.Get(address)
			if err != nil {
				panic(fmt.Sprintf("error downloading %s: %v", address, err))
			}
			if resp.Body != nil {
				defer resp.Body.Close()
			}

			bs, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				panic(fmt.Sprintf("problem reading %s response: %v", address, err))
			}
			cs, err := certutil.ParsePEM(bs)
			if err != nil {
				panic(fmt.Sprintf("problem parsing %s cert: %v", address, err))
			}

			mu.Lock()
			for i := range cs {
				certs = append(certs, &cert{
					fingerprint: certutil.GetHexSHA256Fingerprint(*cs[i]),
					desc: cs[i].Subject.String(),
				})
			}
			mu.Unlock()
		}(&wg, id)
	}

	wg.Wait()

	return certs, nil
}
